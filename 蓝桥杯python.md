### 题目1:妮妮的翻转游戏

##### 问题描述

在蓝桥镇，妮妮发明了一个新的游戏——翻转游戏。游戏中有一个开关，可以处于两种状态：开（用 1 表示）和关（用 0 表示）。妮妮发现，无论开关当前处于何种状态，他都可以通过一次操作使得开关的状态翻转。现在，妮妮告诉你开关当前的状态 $x$，他想知道如果他做一次操作，开关的状态会变成什么。你能帮助他解答这个问题吗？

##### 输入格式

输入仅一行，包含一个整数x(0<x<1)，表示开关当前的状态。

\##### 输出格式

输出一行，表示如果妮妮做一次操作后，开关的状态。

##### 样例输入

0

##### 样例输出

1

#### 编程实现

```python
x = int(input("请输入："))
if x>=0 and x <=1:
    if  x== 0:
        print("1")
    else:
        print("0")
else:
    print("输入错误")
```

### 题目2：小明和完美序列

#### 问题描述

小明又新学了一个概念，叫做完美序列。一个仅包含数字序列被称为完美序列，当且仅当数字序列中每个数字出现的次数等于这个数字。比如 $(1)，(2,2,3,3,3)$。空序列也算。现在小明得到了一个数字序列，他想知道最少要删除多少个数字才能使得这个数字序列成为一个完美序列。

#### 输入格式

输入包括两行。

第一行一个整数n，表示数字序列中数字的个数。

第二行，包括n个整数，是数字序列中具体的每个数字。

#### 输出格式

输出一个整数，表示最少要删除的数字个数。

#### 样例输入

6
3 3 3 1 13 15

#### 样例输出

2

####  题目分析

1. 完美序列的定义：给定一个序列，当且仅当这个序列仅包含数字、且数字序列中每个数字出现的次数等于这个数字。

2. 问题：给你一个序列，从这个序列中删除多少个数字才能使得这个序列编程完美序列。

  \- 最好情况：序列本身就是完美序列，不需要额外删除数字。

   \- 返回0。

  \- 最坏情况：删除序列中所有数字后，序列变成空序列。（题目有说空序列也算是完美序列）

  \- 一般情况：需要删除序列中部分数字，剩下的数字构成完美序列。

   \- 对于序列中一个数字num，记它在序列中出现的次数为c，那么num和c存在以下三种情况。

​    1） `num == c`：不需要额外删除；(2,2,3,3,3)

​    2）`num > c`: 需要全部删除所有的num；3，3

​    3）`num < c`: 为了使`num == c`，需要删除 (c - num)个num。2，2，2

#### 编程实现

```python
n = int(input())
a = list(map(int, input().split()))
d = {}
for x in a:
   if x in d:
       d[x] += 1
   else:
       d[x] = 1
cnt = 0
for v in d.values():
   if v != 1:
       cnt += v - 1

print(cnt)
```

代码解析：

  这段代码首先通过 `input()` 函数读取输入，将第一行的整数 `n` 赋值给变量 `n`，并将第二行的整数列表 `a` 赋值给变量 `a`。

 接下来，使用字典 `d` 来存储每个数字出现的次数。遍历整数列表 `a`，对于每个数字 `x`，如果 `x` 已经在字典 `d` 中，那么将字典 `d` 中该数字的次数加一；否则，将该数字的次数设为1。

 接下来，初始化一个计数器变量 `cnt` 为0。遍历字典 `d` 的所有值 `v`，如果 `v` 不等于1，那么将 `v - 1` 加到计数器 `cnt` 中。

 最后，输出计数器 `cnt` 的值，即为最少要删除的数字个数。

### 题目3：顺子日期

#### 题目描述

小明特别喜欢顺子。顺子指的就是连续的三个数字：123、456 等。顺子日期指的就是在日期的 **yyyymmdd** 表示法中，存在任意连续的三位数是一个顺子的日期。例如 20220123 就是一个顺子日期，因为它出现了一个顺子：123； 而 20221023 则不是一个顺子日期，它一个顺子也没有。小明想知道在整个 2022 年份中，一共有多少个顺子日期?

2022.01.01~2022.12.31

#### 题目分析

2022年是否为闰年？\rightarrow否

\> 闰年
\>
\> - 闰年：四年一闰，百年不闰，四百年再闰。满足以下条件之一即为闰年
\>  - y % 400 == 0
\>  - y % 4 == 0 && y % 100 != 0
\> - 闰年的特点：
\>  - 闰年的二月29天，非闰年的二月28天；
\>  - 闰年全年366天，非闰年全年365天。

2022 % 400 != 0 $ 2022%4!=0

#### 编程实现

解法1：字符串日期

```
res = 0
for i in range(1, 13):
    for j in range(1, 32):
        s = "2022%02d%02d" % (i, j)
        if "012" in s or "123" in s:
            res += 1
print(res)
#  腊月是十二月
```



### 题目4：餐厅排队

#### 题目描述

在蓝桥杯学院的新餐厅，学生们字取餐口形成了一条长队。

小蓝，餐厅的经理，希望能够实时了解队伍最前面和最后面的学生编号。

你需要执行以下三种操作：

1. 学生进入队列：编号为x的学生排到队伍末尾。
2. 学生离开队列：最前面的学生拿到餐后离开队伍。
3. 查询队列状态：输出当前队伍最前面和最后面的学生编号。

请注意，学生们可能会吃完饭后再次排队。

#### 输入格式

首先，你回看到一个整数q，表示你需要执行的操作次数。

接下来的q行，每行将包括一个或两个整数，代表一次操作：

1. 1x：编号为x的学生加入队伍。
2. 2：最前面的学生拿到餐并离开队伍。
3. 3：输出当前队伍最前面和最后面的学生编号（两个编号之间
4. 用一个空格隔开）。

数据范围保证：1< =x,q<=10的五次。进行操作后2和3时。队伍

一定非空。每个学生的编号都是唯一的了。

#### 输出格式

对于每一次的3操作，输出一行包含两个整数，即当前队伍最前面和最后面的学生编号

#### 样式输入

5

1 1

1 3

3

2

3

#### 样式输出

1 3

3 3

#### 说明

对于给出的样例，队伍的变化过程如下：

1. 编号为1 的学生加入队伍，队列变为*q*=[1]。
2. 编号为3 的学生加入队伍，队列变为 *q*=[1,3]。
3. 输出队伍最前面和最后面的学生编号，分别为 1和3.
4. 最前面的学生拿到餐并离开队伍，队列变为 *q*=[3]。
5. 输出队伍最前面和最后面的学生编号，分别为 3和3.

### 编码实现

```python
import os
import sys
from collections import deque
# 请在此输入您的代码
n=int(input())#执行次数
q=deque()
for i in range(n):#开始执行
  a=list(map(int,input().split(" ")))#具体行动
  if a[0]==1:#加入学生
    q.append(a[1])#加到队尾
  elif a[0]==2:#最前面的离开队伍
    q.popleft()#离开
  else:#输出最前面和最后面编号
    print(f"{q[0]} {q[-1]}")
```



## 题目5：小蓝的括号串1

#### 题目描述

小蓝有一个长度为*n* 的括号串，括号串仅由字符 `(` 、 `)` 构成，请你帮他判断一下该括号串是否合法，合法请输出 `Yes` ，反之输出 `No` 。

合法括号序列：

1. 空串是合法括号序列。
2. 若*s* 是合法括号序列，则 `(` &）也是合法括号序列。
3. 若s,t都是合法括号序列，则st，也是合法括号序列。

列如()()。(()).(())()均为合法括号序列。

#### 输入格式

第一行包含一个正整数 n，表示括号串的长度。

第二号包含一个长度为n的括号串。

#### 输出格式

输出共1行，若括号串合法请输出yes,反之输出no.

#### 输入1

18

(()(()))()

#### 输出1

yes

#### 输入2

5

()()(

#### 输出2

no

#### 评测数据规模

对于所有评测数据，1≤*n*≤1×10 ，括号串仅包含两种字符 `(` ， `)` 。

### 编程实现

```python
n = int(input())
a=[]
count=0
for i in input():
    a.append(i)
if n % 2 == 1:
    print('No')
    n=int(n/2)
else:
    x='Yes'
    for i in range(n):
        if a[0]=='(':
            count+=1
            a.pop(0)
            continue
        if a[0]==')':
            count-=1
            a.pop(0)
        if count<0:
            x='No'
            break
    if count!=0:
      x='No'
    print(x)
```

### 题目6：宝藏排序1

[1.宝藏排序Ⅰ - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3225/learning/?page=1&first_category_id=1&name=宝藏排序)

#### 题目描述

在一个神秘的岛屿上，有一支探险队发现了一批宝藏，这批宝藏是以整数数组的形式存在的。每个宝藏上都标有一个数字，代表了其珍贵程度。然而，由于某种神奇的力量，这批宝藏的顺序被打乱了，探险队需要将宝藏按照珍贵程度进行排序，以便更好地研究和保护它们。作为探险队的一员，肖恩需要设计合适的排序算法来将宝藏按照珍贵程度进行从小到大排序。请你帮帮肖恩。

#### 输入格式

输入第一行包括一个数字 *n* ，表示宝藏总共有 n个。

输入的第二行包括 *n* 个数字，第 *i* 个数字 *a*[*i*] 表示第 *i* 个宝藏的珍贵程度。

数据保证 1≤*n*≤1000,1≤*a*[*i*]≤10的六次方。

#### 输出格式

输出*n* 个数字，为对宝藏按照珍贵程度从小到大排序后的数组。

#### 输入

5

1 5 9 3 7

#### 输出

1 3 5 7 9 

#### 编码实现

```python
n = int(input())
m = list(map(int,input().split()))
m.sort()
print(*m)
```

### 题目7：宝藏排序2

#### 题目描述

在一个神秘的岛屿上，有一支探险队发现了一批宝藏，这批宝藏是以整数数组的形式存在的。每个宝藏上都标有一个数字，代表了其珍贵程度。然而，由于某种神奇的力量，这批宝藏的顺序被打乱了，探险队需要将宝藏按照珍贵程度进行排序，以便更好地研究和保护它们。作为探险队的一员，肖恩需要设计合适的排序算法来将宝藏按照珍贵程度进行从小到大排序。请你帮帮肖恩。

#### 输入格式

输入第一行包括一个数字 *n* ，表示宝藏总共有 n个。

输入的第二行包括 *n* 个数字，第 *i* 个数字 *a*[*i*] 表示第 *i* 个宝藏的珍贵程度。

数据保证 1≤*n*≤10的五次方,1≤*a*[*i*]≤10的九次方。

#### 输入

5

1 5 9 3 7

#### 输出

1 3 5 7 9 

#### 编码实现

```
n=int(input())
a=list(map(int,input().split()))
a.sort()
result=" ".join(map(str,a))
print(result)
```

### 题目8：分糖果

[2.分糖果 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/2928/learning/?page=1&first_category_id=1&name=分糖果)

#### 题目描述

最近暑期特训算法班的同学们表现出色，他们的老师肖恩决定给他们分发糖果。肖恩购买了 *n* 个不同种类的糖果，用小写的阿拉伯字母表示。每个糖果必须分发给一个同学，并且每个同学至少要分到一个糖果。同学们的开心程度定义为他们所分到的糖果组成的字符串 *s*[*i*] 的字典序。肖恩希望同学们的开心程度相差尽量小，因此他要找到一种方案，使得所有糖果组成的字符串中字典序最大的字符串尽可能小。请输出能够实现字典序最小可能的 max(*s*[1],*s*[2],*s*[3],...,*s*[*x*]) 。

#### 输入格式

第一行输入两个整数 *n* 和 *x* ，分别表示有 *n* 个糖果 *x* 个同学。

第二行输入一个长度为 *n* 的字符串 *S* ， *S*[*i*] 表示第 *i* 个糖果的种类。

数据保证 1≤*n*≤10的六次方,1≤*x*≤*n*,*S*[*i*]∈[’a','z']。

#### 输出格式

输出一个字符串，为所有糖果组成的字符串中字典序最大的字符串最小的可能值。

#### 输入

6 2 

caabdc

#### 输出

abccd

```python

n, x = map(int, input().split())
S = input()
S = sorted(S)  # 将糖果S按从小价值的到大价值的排序（方便确定起始字母） 

# 第一种情况，第一轮分配后已经决出【唯一的】不同“起始字母”，故那个不同的字母就是最大的(字典序" b "始终大于" azzzzzzzzzz ")
if S[x - 1] != S[0]:  # 分配给最后一个小朋友的糖果价值 > 第一个小朋友的糖果价值（由于已排序，故不等于就是大于）
    print(S[x - 1])
    # 其实你写到这里已经可以通过90%的数据了

else:  # 第二种情况，第一批分配后每个人拿到等价值的糖果，即每个“起始字母”都相同，且除去起始字母外，后面的字母都相同

    if S[x] == S[-1]:  # 保证后面剩余糖果都一样 
        print(S[x - 1], end='')  # 输出“起始字母”
        for i in range(x, n, x):  # 接着模拟输出第一个小朋友累积分配到的糖果（步长为小朋友的个数）
            print(S[i], end='')

    # 第三种情况，“起始字母”相同，但是后面拿到的糖果不相同（样例的情况）
    else:
        for i in S[x - 1:]:  # 假如俩同学，字符串为aabccd,则为 a；abccd
            print(i, end='')
```

### 翻转

[0翻转 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3520/learning/)

代码

```
n = int(input())
for i in range(n):
    input2 = input()
    input1 = input()
    input1 = list(input1)
    input2 = list(input2)
    count =0
    for i in range(len(input1)):
        if i == (len(input1)-2):
            break
        text =input1[i] + input1[i+1] + input1[i+2]
        if text == '010' or text == '101':
            if input1[i+1] !=input2[i+1]:
                input1[i+1] = input2[i+1]
                count +=1
    if input1 == input2:
        print(count)
    else:
        print(-1)
```

### 三国游戏

[0三国游戏 - 蓝桥云课 (lanqiao.cn)](https://www.lanqiao.cn/problems/3518/learning/?isWithAnswer=true)

```
n = int(input())
A = list(map(int,input().split()))
B = list(map(int,input().split()))
C = list(map(int,input().split()))
X = []
Y = []
Z = []
for i in range(n):
    X.append(A[i] - B[i] - C[i])
    Y.append(B[i] - A[i] - C[i])
    Z.append(C[i] - A[i] - B[i])
X = sorted(X,reverse=True)
Y = sorted(Y,reverse=True)
Z = sorted(Z,reverse=True)
X_win,Y_win,Z_win = 0,0,0
X_count,Y_count,Z_count = 0,0,0
for i in range(n):
    X_win += X[i]
    Y_win += Y[i]
    Z_win += Z[i]
    if X_win>0:
        X_count += 1
    if Y_win>0:
        Y_count += 1
    if Z_win>0:
        Z_count += 1
if max([X_count,Y_count,Z_count]) == 0:
    print(-1)
else:
    print(max([X_count,Y_count,Z_count]))

```

